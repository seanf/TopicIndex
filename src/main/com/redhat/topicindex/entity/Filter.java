package com.redhat.topicindex.entity;

// Generated Apr 14, 2011 12:17:30 PM by Hibernate Tools 3.4.0.CR1

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Query;
import javax.persistence.Transient;
import javax.persistence.UniqueConstraint;

import static ch.lambdaj.Lambda.filter;
import static ch.lambdaj.Lambda.having;
import static ch.lambdaj.Lambda.on;
import static javax.persistence.GenerationType.IDENTITY;
import static org.hamcrest.Matchers.equalTo;

import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;

import org.hibernate.envers.Audited;
import org.hibernate.validator.Length;
import org.hibernate.validator.NotNull;
import org.jboss.seam.Component;
import org.joda.time.DateTime;
import org.joda.time.format.ISODateTimeFormat;

import com.redhat.ecs.commonutils.CollectionUtilities;
import com.redhat.topicindex.utils.SkynetExceptionUtilities;
import com.redhat.topicindex.filter.TopicFilter;
import com.redhat.topicindex.utils.Constants;
import com.redhat.topicindex.utils.EntityUtilities;
import com.redhat.topicindex.utils.docbookbuilding.DocbookBuildingOptions;
import com.redhat.topicindex.utils.structures.tags.UICategoryData;
import com.redhat.topicindex.utils.structures.tags.UIProjectCategoriesData;
import com.redhat.topicindex.utils.structures.tags.UIProjectData;
import com.redhat.topicindex.utils.structures.tags.UITagData;

/**
 * Filter generated by hbm2java
 */
@Entity
@Audited
@Table(name = "Filter", uniqueConstraints = @UniqueConstraint(columnNames =
{ "FilterName" }))
public class Filter implements java.io.Serializable
{
	public static final String SELECT_ALL_QUERY = "select filter from Filter filter";
	/** Serializable version identifier */
	private static final long serialVersionUID = 1378015715100292871L;
	private Integer filterId;
	private String filterName;
	private String filterDescription;
	private Set<FilterTag> filterTags = new HashSet<FilterTag>(0);
	private Set<FilterCategory> filterCategories = new HashSet<FilterCategory>(0);
	private Set<FilterField> filterFields = new HashSet<FilterField>(0);
	private Set<FilterOption> filterOptions = new HashSet<FilterOption>(0);

	public Filter()
	{
	}

	public Filter(final String filterName)
	{
		this.filterName = filterName;
	}

	public Filter(final String filterName, final String filterDescription, final Set<FilterTag> filterTags, final Set<FilterCategory> filterCategories)
	{
		this.filterName = filterName;
		this.filterDescription = filterDescription;
		this.filterTags = filterTags;
		this.filterCategories = filterCategories;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)
	@Column(name = "FilterID", unique = true, nullable = false)
	public Integer getFilterId()
	{
		return this.filterId;
	}

	public void setFilterId(Integer filterId)
	{
		this.filterId = filterId;
	}

	@Column(name = "FilterName", nullable = false, length = 512)
	@NotNull
	@Length(max = 512)
	public String getFilterName()
	{
		return this.filterName;
	}

	public void setFilterName(final String filterName)
	{
		this.filterName = filterName;
	}

	// @Column(name = "FilterDescription", length = 65535)
	@Column(name = "FilterDescription", columnDefinition = "TEXT")
	@Length(max = 65535)
	public String getFilterDescription()
	{
		return this.filterDescription;
	}

	public void setFilterDescription(final String filterDescription)
	{
		this.filterDescription = filterDescription;
	}

	@OneToMany(fetch = FetchType.EAGER, mappedBy = "filter", orphanRemoval = true, cascade = CascadeType.ALL)
	public Set<FilterTag> getFilterTags()
	{
		return this.filterTags;
	}

	public void setFilterTags(final Set<FilterTag> filterTags)
	{
		this.filterTags = filterTags;
	}

	@OneToMany(fetch = FetchType.EAGER, mappedBy = "filter", orphanRemoval = true, cascade = CascadeType.ALL)
	public Set<FilterCategory> getFilterCategories()
	{
		return this.filterCategories;
	}

	public void setFilterCategories(final Set<FilterCategory> filterCategories)
	{
		this.filterCategories = filterCategories;
	}

	@OneToMany(fetch = FetchType.EAGER, mappedBy = "filter", orphanRemoval = true, cascade = CascadeType.ALL)
	public Set<FilterField> getFilterFields()
	{
		return filterFields;
	}

	public void setFilterFields(final Set<FilterField> filterFields)
	{
		this.filterFields = filterFields;
	}

	@OneToMany(fetch = FetchType.EAGER, mappedBy = "filter", orphanRemoval = true, cascade = CascadeType.ALL)
	public Set<FilterOption> getFilterOptions()
	{
		return filterOptions;
	}

	public void setFilterOptions(final Set<FilterOption> filterOptions)
	{
		this.filterOptions = filterOptions;
	}

	/**
	 * Loops through the FilterTags held by this Filter, and returns the state
	 * of the tag if it exists, and -1 if it does not.
	 * 
	 * @param tagID
	 *            The id of the tag to get the state of
	 * @return -1 if the tag was not found, otherwise the state of the tag
	 */
	public int hasTag(final Integer tagID)
	{
		for (final FilterTag tag : this.getFilterTags())
		{
			if (tag.getTag().getTagId().equals(tagID))
				return tag.getTagState();
		}

		return -1;
	}

	public ArrayList<Integer> hasCategory(final Integer categoryId)
	{
		ArrayList<Integer> states = new ArrayList<Integer>();

		for (final FilterCategory cat : this.getFilterCategories())
		{
			if (cat.getCategory().getCategoryId().equals(categoryId))
				states.add(cat.getCategoryState());
		}

		return states;
	}

	/**
	 * Not all FilterTags assigned to a filter have an associated
	 * FilterCategory. If a FilterTags belongs to a category that does not have
	 * an associated FilterCategory, the default boolean logic is used.
	 * 
	 * This function returns all the categories that the tags in this filter
	 * belong to. These are then matched to any associated FilterCategorys to
	 * find out how the tags are matched (i.e. are we matching all the tags
	 * ("And" logic), or one or more of the tags matches ("Or" logic)), using
	 * the default logic ("Or") if no associated FilterCategory exists.
	 * 
	 * @return An ArrayList containing the Category IDs that the tags in this
	 *         filter belong to
	 */
	@Transient
	public ArrayList<Category> getFilterTagCategories()
	{
		final ArrayList<Category> categories = new ArrayList<Category>();

		for (final FilterTag tag : this.filterTags)
		{
			for (final TagToCategory category : tag.getTag().getTagToCategories())
				if (!categories.contains(category.getCategory()))
					categories.add(category.getCategory());
		}

		return categories;
	}

	@Transient
	public ArrayList<Project> getFilterTagProjects()
	{
		final ArrayList<Project> projects = new ArrayList<Project>();

		for (final FilterTag filterTag : this.filterTags)
		{
			final Tag tag = filterTag.getTag();
			final Set<TagToProject> tagToProjects = tag.getTagToProjects();

			if (tagToProjects.size() != 0)
			{
				for (final TagToProject tagToProject : tagToProjects)
				{
					final Project project = tagToProject.getProject();

					if (!projects.contains(project))
						projects.add(project);
				}
			}
			else
			{
				if (!projects.contains(null))
					projects.add(null);
			}
		}

		return projects;
	}

	@Transient
	public String getFilterTitle()
	{
		String desc = "";

		/* Loop over all the categories that the filter tags belong to */
		for (final Category category : this.getFilterTagCategories())
		{
			String categoryDesc = category.getCategoryName() + ": ";
			String tagDesc = "";

			/* This will be shown in the topic list results title */
			String internalLogic = Constants.DEFAULT_INTERNAL_LOGIC;

			/* Find out if the category does not have the default internal logic */
			final Set<FilterCategory> filterCategories = this.getFilterCategories();
			for (final FilterCategory filterCategory : filterCategories)
			{
				/*
				 * if a filter category has been saved that matches the category
				 * we are looking at now..
				 */
				if (filterCategory.getCategory().equals(category))
				{
					/*
					 * ...and it defines an internal logic state, update the
					 * internalLogic variable
					 */
					if (filterCategory.getCategoryState() == Constants.CATEGORY_INTERNAL_AND_STATE)
						internalLogic = Constants.AND_LOGIC;
					else if (filterCategory.getCategoryState() == Constants.CATEGORY_INTERNAL_OR_STATE)
						internalLogic = Constants.OR_LOGIC;
					break;
				}
			}

			for (final FilterTag tag : this.filterTags)
			{
				if (tag.getTag().isInCategory(category.getCategoryId()))
				{
					if (tagDesc.length() != 0)
						tagDesc += " " + internalLogic + " ";

					if (tag.getTagState() == Constants.NOT_MATCH_TAG_STATE)
						tagDesc += "Not ";

					tagDesc += tag.getTag().getTagName();
				}
			}

			if (desc.length() != 0)
				desc += " ";

			desc += categoryDesc + tagDesc;
		}

		if (this.getFilterFields().size() != 0)
		{
			String searchFilters = "";

			for (final FilterField filterField : this.getFilterFields())
			{
				if (searchFilters.length() != 0)
					searchFilters += ", ";
				searchFilters += " " + filterField.getDescription() + " = " + filterField.getValue();
			}

			if (desc.length() != 0)
				desc += " ";

			desc += "Search Filters:" + searchFilters;
		}

		return "[ " + desc + " ]";
	}

	/**
	 * Translate the contents of this filter, its tags and categories into
	 * variables that can be appended to a url
	 * 
	 * @return
	 */
	@Transient
	public HashMap<String, String> getUrlVariables()
	{
		final HashMap<String, String> vars = new HashMap<String, String>();

		for (final FilterTag filterTag : this.filterTags)
		{
			final Tag tag = filterTag.getTag();

			if (filterTag.getTagState() == Constants.MATCH_TAG_STATE)
			{
				vars.put(Constants.MATCH_TAG + tag.getTagId(), Constants.MATCH_TAG_STATE + "");
			}
			else if (filterTag.getTagState() == Constants.NOT_MATCH_TAG_STATE)
			{
				vars.put(Constants.MATCH_TAG + tag.getTagId(), Constants.NOT_MATCH_TAG_STATE + "");
			}
		}

		for (final FilterCategory filterCategory : this.filterCategories)
		{
			final Category category = filterCategory.getCategory();
			final Project project = filterCategory.getProject();

			if (filterCategory.getCategoryState() == Constants.CATEGORY_INTERNAL_AND_STATE)
			{
				vars.put(Constants.CATEORY_INTERNAL_LOGIC + category.getCategoryId() + (project == null ? "" : "-" + project.getProjectId()), Constants.AND_LOGIC);
			}

			// don't add a url var for the "or" internal logic, as this is the
			// default

			else if (filterCategory.getCategoryState() == Constants.CATEGORY_EXTERNAL_OR_STATE)
			{
				vars.put(Constants.CATEORY_EXTERNAL_LOGIC + category.getCategoryId() + (project == null ? "" : "-" + project.getProjectId()), Constants.OR_LOGIC);
			}

			// don't add a url var for the "and" external logic, as this is the
			// default
		}

		boolean foundFilterField = false;
		boolean foundFilterFieldLogic = false;
		for (final FilterField filterField : this.getFilterFields())
		{
			vars.put(filterField.getField(), filterField.getValue());
			if (!filterField.getField().equals(Constants.TOPIC_LOGIC_FILTER_VAR))
				foundFilterField = true;
			else
				foundFilterFieldLogic = true;
		}

		/*
		 * if we have found some filter fields, but did not find the filter
		 * logic, use the default value
		 */
		if (foundFilterField && !foundFilterFieldLogic)
			vars.put(Constants.TOPIC_LOGIC_FILTER_VAR, Constants.TOPIC_LOGIC_FILTER_VAR_DEFAULT_VALUE);

		return vars;
	}

	public String buildFilterUrlVars()
	{
		final HashMap<String, String> vars = this.getUrlVariables();
		String urlVars = "";

		for (final String urlVarKey : vars.keySet())
		{
			if (urlVars.length() != 0)
				urlVars += "&";
			urlVars += urlVarKey + "=" + vars.get(urlVarKey);
		}

		return urlVars;
	}

	/**
	 * This function is used to create the HQL query where clause that is
	 * appended to the generic EJBQL (as created in default EntityList objects)
	 * select statement. It takes the request parameters to get the tags that
	 * are to be included in the clause, groups them by category, and then take
	 * additional request parameters to define the boolean operations to use
	 * between tags in a category, and between categories.
	 * 
	 * @return the clause to append to the EJBQL select statement
	 */
	public String buildQuery()
	{
		// the categories to be ANDed will be added to this string
		String andQueryBlock = "";
		// the categories to be ORed will be added to this string
		String orQueryBlock = "";

		// loop over the projects that the tags in this filter are assigned to
		for (final Project project : this.getFilterTagProjects())
		{
			// loop over the categories that the tags in this filter are
			// assigned to
			for (final Category category : this.getFilterTagCategories())
			{
				// define the default logic used for the FilterTag categories
				String catInternalLogic = Constants.OR_LOGIC;
				String catExternalLogic = Constants.AND_LOGIC;

				/*
				 * Now loop over the FilterCategories, looking for any
				 * categories that specify a particular boolean logic to apply.
				 * Remember that not all FilterTags will have an associated
				 * FilterCategory that specifies the logic to use, in which case
				 * the default logic defined above will be used.
				 */
				final Set<FilterCategory> filterCatgeories = this.getFilterCategories();
				for (final FilterCategory filterCatgeory : filterCatgeories)
				{
					final boolean categoryMatch = category.equals(filterCatgeory.getCategory());
					/*
					 * project or filterCatgeory.getProject() might be null.
					 * CollectionUtilities.isEqual deals with this situation
					 */
					final boolean projectMatch = CollectionUtilities.isEqual(project, filterCatgeory.getProject());

					if (categoryMatch && projectMatch)
					{
						final int categoryState = filterCatgeory.getCategoryState();

						if (categoryState == Constants.CATEGORY_INTERNAL_AND_STATE)
							catInternalLogic = Constants.AND_LOGIC;
						else if (categoryState == Constants.CATEGORY_INTERNAL_OR_STATE)
							catInternalLogic = Constants.OR_LOGIC;
						else if (categoryState == Constants.CATEGORY_EXTERNAL_AND_STATE)
							catExternalLogic = Constants.AND_LOGIC;
						else if (categoryState == Constants.CATEGORY_EXTERNAL_OR_STATE)
							catExternalLogic = Constants.OR_LOGIC;
					}
				}

				/*
				 * now build up the HQL that checks to see if the FilterTags
				 * exist (or not) in this category
				 */
				String categoryBlock = "";

				boolean matchedSomeTags = false;

				final Set<FilterTag> filterTags = this.getFilterTags();
				for (final FilterTag filterTag : filterTags)
				{
					final Tag tag = filterTag.getTag();

					/*
					 * first check to make sure that the FilterTag is actually
					 * associated with the category we are looking at now
					 */
					if (tag.isInCategory(category) && tag.isInProject(project))
					{
						matchedSomeTags = true;

						/* get the TagID for convenience */
						final String value = tag.getTagId().toString();
						/*
						 * a FilterTag state of 1 "means exists in category",
						 * and 0 means "does not exist in category"
						 */
						final boolean matchTag = filterTag.getTagState() == Constants.MATCH_TAG_STATE;

						if (categoryBlock.length() != 0)
							categoryBlock += " " + catInternalLogic + " ";

						if (matchTag)
						{
							/* match the tag in this category */
							categoryBlock += "exists (select 1 from TopicToTag topicToTag where topicToTag.topic = topic and topicToTag.tag.tagId = " + value + ") ";
						}
						else
						{
							/*
							 * make sure this tag does not exist in this
							 * category
							 */
							categoryBlock += "not exists (select 1 from TopicToTag topicToTag where topicToTag.topic = topic and topicToTag.tag.tagId = " + value + ") ";
						}
					}
				}

				if (matchedSomeTags)
				{
					categoryBlock = "(" + categoryBlock + ")";

					// append this clause to the appropriate block
					if (catExternalLogic.equals(Constants.AND_LOGIC))
					{
						if (andQueryBlock.length() != 0)
							andQueryBlock += " " + Constants.AND_LOGIC + " ";

						andQueryBlock += categoryBlock;
					}
					else
					{
						if (orQueryBlock.length() != 0)
							orQueryBlock += " " + Constants.OR_LOGIC + " ";

						orQueryBlock += categoryBlock;
					}
				}

			}
		}

		/*
		 * Do an initial loop over the FilterFields, looking for the field logic
		 * value
		 */
		String filterFieldQueryBlock = "";
		String filterFieldsLogic = "AND";
		for (final FilterField filterField : this.getFilterFields())
		{
			if (filterField.getField().equals(Constants.TOPIC_LOGIC_FILTER_VAR))
			{
				filterFieldsLogic = filterField.getValue();
				break;
			}
		}

		/* Now add the SQL for the fields */

		String startCreateDate = null;
		String endCreateDate = null;
		DateTime startEditDate = null;
		DateTime endEditDate = null;

		for (final FilterField filterField : this.getFilterFields())
		{
			final String fieldName = filterField.getField();
			final String fieldValue = filterField.getValue();

			String thisRestriction = "";

			if (fieldName.equals(Constants.TOPIC_IDS_FILTER_VAR))
			{
				thisRestriction = "topic.topicId in (" + fieldValue + ")";
			}
			else if (fieldName.equals(Constants.TOPIC_TITLE_FILTER_VAR))
			{
				thisRestriction = "lower(topic.topicTitle) like lower('%" + fieldValue + "%')";
			}
			else if (fieldName.equals(Constants.TOPIC_TITLE_FILTER_VAR))
			{
				thisRestriction = "lower(topic.topicTitle) like lower('%" + fieldValue + "%')";
			}
			else if (fieldName.equals(Constants.TOPIC_XML_FILTER_VAR))
			{
				thisRestriction = "lower(topic.topicXML) like lower('%" + fieldValue + "%')";
			}
			else if (fieldName.equals(Constants.TOPIC_DESCRIPTION_FILTER_VAR))
			{
				thisRestriction = "lower(topic.topicText) like lower('%" + fieldValue + "%')";
			}
			else if (fieldName.equals(Constants.TOPIC_ADDED_BY_FILTER_VAR))
			{
				thisRestriction = "lower(topic.topicAddedBy) like lower('%" + fieldValue + "%')";
			}
			else if (fieldName.equals(Constants.TOPIC_HAS_RELATIONSHIPS))
			{
				thisRestriction = "topic.parentTopicToTopics.size >= 1";
			}
			else if (fieldName.equals(Constants.TOPIC_HAS_INCOMING_RELATIONSHIPS))
			{
				thisRestriction = "topic.childTopicToTopics.size >= 1";
			}
			else if (fieldName.equals(Constants.TOPIC_RELATED_TO) || fieldName.equals(Constants.TOPIC_RELATED_FROM))
			{
				try
				{
					final Integer topicId = Integer.parseInt(fieldValue);
					final String relatedTopics = EntityUtilities.getRelatedTopicIDsString(topicId);

					thisRestriction = "topic.topicId in (" + relatedTopics + ")";
				}
				catch (final Exception ex)
				{
					SkynetExceptionUtilities.handleException(ex, false, "An invalid Topic ID was stored for a Filter in the database");
				}
			}
			else if (fieldName.equals(Constants.TOPIC_HAS_XML_ERRORS))
			{
				try
				{
					final Boolean hasXMLErrors = Boolean.valueOf(fieldValue);
					if (hasXMLErrors)
						thisRestriction = "topic.topicSecondOrderData.topicXMLErrors is not null";
				}
				catch (final Exception ex)
				{
					SkynetExceptionUtilities.handleException(ex, false, "An invalid boolean value was stored for a Filter in the database");
				}

			}
			else if (fieldName.equals(Constants.TOPIC_EDITED_IN_LAST_DAYS))
			{
				try
				{
					final Integer days = Integer.parseInt(fieldValue);
					final DateTime date = new DateTime().minusDays(days);
					final String editedTopics = EntityUtilities.getEditedEntitiesString(Topic.class, "topicId", date, null);
					thisRestriction += "topic.topicId in (" + editedTopics + ")";
				}
				catch (final Exception ex)
				{
					SkynetExceptionUtilities.handleException(ex, false, "An invalid integer was stored for a Filter in the database");
				}
			}

			else if (fieldName.equals(Constants.TOPIC_STARTDATE_FILTER_VAR))
			{

					startCreateDate = fieldValue;


			}
			else if (fieldName.equals(Constants.TOPIC_ENDDATE_FILTER_VAR))
			{

					endCreateDate = fieldValue;

			}

			else if (fieldName.equals(Constants.TOPIC_STARTEDITDATE_FILTER_VAR))
			{
				try
				{
					startEditDate = ISODateTimeFormat.dateTime().parseDateTime(fieldValue);
				}
				catch (final Exception ex)
				{
					SkynetExceptionUtilities.handleException(ex, false, "An invalid DateTime string was stored by the Filter for the start edit date");
				}
			}
			else if (fieldName.equals(Constants.TOPIC_ENDEDITDATE_FILTER_VAR))
			{
				try
				{
					endEditDate = ISODateTimeFormat.dateTime().parseDateTime(fieldValue);
				}
				catch (final Exception ex)
				{
					SkynetExceptionUtilities.handleException(ex, false, "An invalid DateTime string was stored by the Filter for the end edit date");
				}
			}

			if (thisRestriction.length() != 0)
			{
				if (filterFieldQueryBlock.length() != 0)
					filterFieldQueryBlock += " " + filterFieldsLogic + " ";

				filterFieldQueryBlock += thisRestriction;
			}
		}

		if (startCreateDate != null || endCreateDate != null)
		{
			String thisRestriction = "";

			if (startCreateDate != null)
			{
				thisRestriction = "topic.topicTimeStamp >= '"  + startCreateDate + "'";
			}

			if (endCreateDate != null)
			{
				if (startCreateDate != null)
					thisRestriction += " and ";

				thisRestriction += "topic.topicTimeStamp <= '" + endCreateDate + "'";
			}

			if (thisRestriction.length() != 0)
			{
				if (filterFieldQueryBlock.length() != 0)
					filterFieldQueryBlock += " " + filterFieldsLogic + " ";

				filterFieldQueryBlock += thisRestriction;
			}

		}

		if (startEditDate != null || endEditDate != null)
		{
			final String editedTopics = EntityUtilities.getEditedEntitiesString(Topic.class, "topicId", startEditDate, endEditDate);
			final String thisRestriction = "topic.topicId in (" + editedTopics + ")";

			if (thisRestriction.length() != 0)
			{
				if (filterFieldQueryBlock.length() != 0)
					filterFieldQueryBlock += " " + filterFieldsLogic + " ";

				filterFieldQueryBlock += thisRestriction;
			}
		}

		String query = filterFieldQueryBlock;

		/*
		 * build up the category query if some conditions were specified if not,
		 * we will just return an empty string
		 */
		if (andQueryBlock.length() != 0 || orQueryBlock.length() != 0)
		{
			// add the and categories
			if (andQueryBlock.length() != 0)
				query += (query.length() != 0 ? " And " : "") + "(" + andQueryBlock + ")";

			// add the or categories
			if (orQueryBlock.length() != 0)
				query += (query.length() != 0 ? " And " : "") + "(" + orQueryBlock + ")";
		}

		/*
		 * add the where clause have to join the topic and its collection of
		 * tags in order for the filter to work
		 */
		if (query.length() != 0)
			query = " where " + query;
		
		return Topic.SELECT_ALL_QUERY + query;
		
	}

	public void syncFilterWithTags(final UIProjectData selectedTags)
	{
		final EntityManager entityManager = (EntityManager) Component.getInstance("entityManager");

		/*
		 * loop through the list of tags selected via the checkboxes, and update
		 * their representation in the Filter
		 */

		/*
		 * We have to deal with the situation that can arise when a tag is in
		 * two different projects or categories. The selectedFilterTags
		 * collection will hold all the FilterTags that are created in response
		 * to a tag being selected once. We can then reference this collection
		 * to prevent the FilterTag from being removed in response to a tag not
		 * being selected in another location.
		 */
		final List<FilterTag> selectedFilterTags = new ArrayList<FilterTag>();
		for (final UIProjectCategoriesData project : selectedTags.getProjectCategories())
		{
			for (final UICategoryData category : project.getCategories())
			{
				for (final UITagData tag : category.getTags())
				{
					final boolean tagSelected = tag.isSelected();
					final boolean notTagSelected = tag.isNotSelected();
					final int state = notTagSelected ? Constants.NOT_MATCH_TAG_STATE : Constants.MATCH_TAG_STATE;

					if (tagSelected)
					{
						boolean found = false;
						for (final FilterTag filterTag : this.getFilterTags())
						{
							if (filterTag.getTag().getTagId().equals(tag.getId()))
							{
								filterTag.setTagState(state);
								selectedFilterTags.add(filterTag);
								found = true;
								break;
							}
						}

						if (!found)
						{
							final Tag dbTag = entityManager.getReference(Tag.class, tag.getId());

							final FilterTag filterTag = new FilterTag();
							selectedFilterTags.add(filterTag);
							filterTag.setFilter(this);
							filterTag.setTag(dbTag);
							filterTag.setTagState(state);

							this.getFilterTags().add(filterTag);
						}
					}
				}
			}
		}

		/*
		 * now loop through the tags in the Filter, and remove any that are no
		 * longer checked in the gui
		 */

		final ArrayList<FilterTag> removeTags = new ArrayList<FilterTag>();

		for (final FilterTag filterTag : this.getFilterTags())
		{
			/*
			 * don't attempt to remove a FilterTag that was specifically added
			 * above
			 */
			if (!selectedFilterTags.contains(filterTag))
			{
				boolean found = false;
				for (final UIProjectCategoriesData project : selectedTags.getProjectCategories())
				{

					for (final UICategoryData category : project.getCategories())
					{
						for (final UITagData tag : category.getTags())
						{
							final boolean tagSelected = tag.isSelected();
							if (!tagSelected && tag.getId().equals(filterTag.getTag().getTagId()))
							{
								found = true;
								break;
							}
						}
					}
				}

				// add to a temporary container so we don't modify the
				// collection we
				// are looping over
				if (found)
					removeTags.add(filterTag);
			}
		}

		// now clean out the obsolete tags
		for (final FilterTag filterTag : removeTags)
			this.getFilterTags().remove(filterTag);
	}

	public void syncFilterWithFieldUIElements(final TopicFilter topic)
	{
		for (final String fieldName : TopicFilter.getFilterNames().keySet())
			syncFilterField(fieldName, topic.getFieldValue(fieldName), TopicFilter.getFilterNames().get(fieldName));
	}

	private void syncFilterField(final String fieldName, final String fieldValue, final String fieldDescription)
	{
		// get the database filterfield object that matches the fieldName
		final List<FilterField> filterField = filter(having(on(FilterField.class).getField(), equalTo(fieldName)), this.getFilterFields());

		/*
		 * if fieldValue is set to a value, we need to modify or add a
		 * FilterField entity
		 */
		if (fieldValue != null && fieldValue.trim().length() != 0)
		{
			final String fixedFieldValue = fieldValue.trim();

			FilterField newField = null;

			// add a new FilterField entity
			if (filterField.size() == 0)
			{
				newField = new FilterField();
				newField.setFilter(this);
				newField.setField(fieldName);
				newField.setValue(fixedFieldValue);
				newField.setDescription(fieldDescription);
				this.getFilterFields().add(newField);
			}
			// update a FilterField entity
			else if (filterField.size() == 1)
			{
				newField = filterField.get(0);
				newField.setValue(fixedFieldValue);
				newField.setDescription(fieldDescription);
			}
		}
		else
		{
			// remove the FilterField entity
			if (filterField.size() == 1)
				this.getFilterFields().remove(filterField.get(0));
		}
	}

	public void syncFilterWithCategories(final UIProjectData selectedTags)
	{
		final EntityManager entityManager = (EntityManager) Component.getInstance("entityManager");

		for (final UIProjectCategoriesData project : selectedTags.getProjectCategories())
		{
			final Integer projKey = project.getId();

			for (final UICategoryData category : project.getCategories())
			{
				final Integer catKey = category.getId();

				/*
				 * match the radioboxes with the internal db flag used to
				 * indicate logic
				 */
				int dbIntCatLogic;
				int dbExtCatLogic;

				final String intCatLogic = category.getInternalLogic();
				final String extCatLogic = category.getExternalLogic();

				if (intCatLogic.equals(Constants.AND_LOGIC))
					dbIntCatLogic = Constants.CATEGORY_INTERNAL_AND_STATE;
				else
					dbIntCatLogic = Constants.CATEGORY_INTERNAL_OR_STATE;

				if (extCatLogic.equals(Constants.AND_LOGIC))
					dbExtCatLogic = Constants.CATEGORY_EXTERNAL_AND_STATE;
				else
					dbExtCatLogic = Constants.CATEGORY_EXTERNAL_OR_STATE;

				/*
				 * set the existing filter category states to the ones selected
				 * in the gui
				 */
				boolean foundIntCat = false;
				boolean foundExtCat = false;
				final Set<FilterCategory> filterCategories = this.getFilterCategories();
				for (final FilterCategory filterCategory : filterCategories)
				{
					final int filterCategoryID = filterCategory.getCategory().getCategoryId();

					/*
					 * The UIProjectCategoriesData class uses
					 * Constants.COMMON_PROJECT_ID to denote the common project.
					 * The FilterCategory uses a null project to denote the
					 * common project. We handle this special case here.
					 */
					final Project filterProject = filterCategory.getProject();
					final int filterProjectID = filterProject == null ? Constants.COMMON_PROJECT_ID : filterCategory.getProject().getProjectId();

					if (filterCategoryID == catKey && filterProjectID == projKey)
					{
						/*
						 * we are looking at the internal logic filter, and it
						 * does not match what the user just selected
						 */
						if ((filterCategory.getCategoryState() == Constants.CATEGORY_INTERNAL_AND_STATE || filterCategory.getCategoryState() == Constants.CATEGORY_INTERNAL_OR_STATE))
						{
							if (filterCategory.getCategoryState() != dbIntCatLogic)
								filterCategory.setCategoryState(dbIntCatLogic);
							foundIntCat = true;
						}

						/*
						 * we are looking at the external logic filter, and it
						 * does not match what the user just selected
						 */
						if ((filterCategory.getCategoryState() == Constants.CATEGORY_EXTERNAL_AND_STATE || filterCategory.getCategoryState() == Constants.CATEGORY_EXTERNAL_OR_STATE))
						{
							if (filterCategory.getCategoryState() != dbExtCatLogic)
								filterCategory.setCategoryState(dbExtCatLogic);
							foundExtCat = true;
						}
					}

					/*
					 * if we find both the internal and external filter
					 * categories, we can exit the loop
					 */
					if (foundIntCat && foundExtCat)
						break;
				}

				// create the missing filter categories
				if (!foundIntCat || !foundExtCat)
				{
					final Category categoryEntity = entityManager.find(Category.class, catKey);
					final Project projectEntity = entityManager.find(Project.class, projKey);

					if (!foundIntCat)
						createFilterCategory(projectEntity, categoryEntity, dbIntCatLogic);
					if (!foundExtCat)
						createFilterCategory(projectEntity, categoryEntity, dbExtCatLogic);
				}
			}
		}
	}

	/**
	 * A utility function that persists a FilterCategory object to the database
	 */
	private void createFilterCategory(final Project project, final Category category, final Integer state)
	{
		final FilterCategory filterCategory = new FilterCategory();
		filterCategory.setCategoryState(state);
		filterCategory.setFilter(this);
		filterCategory.setProject(project);
		filterCategory.setCategory(category);
		this.getFilterCategories().add(filterCategory);
	}

	public void syncWithDocbookOptions(final DocbookBuildingOptions options)
	{
		final List<String> docbookOptions = DocbookBuildingOptions.getOptionNames();
		for (final String option : docbookOptions)
		{
			boolean found = false;
			for (final FilterOption filterOption : this.filterOptions)
			{
				if (filterOption.getFilterOptionName().equals(option))
				{
					found = true;
					filterOption.setFilterOptionValue(options.getFieldValue(option));
				}
			}

			if (!found)
			{
				final FilterOption filterOption = new FilterOption();
				filterOption.setFilter(this);
				filterOption.setFilterOptionName(option);
				filterOption.setFilterOptionValue(options.getFieldValue(option));
				this.filterOptions.add(filterOption);
			}
		}

	}

}
