package com.redhat.topicindex.entity;

// Generated Apr 14, 2011 12:17:30 PM by Hibernate Tools 3.4.0.CR1

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Transient;
import javax.persistence.UniqueConstraint;

import static javax.persistence.GenerationType.IDENTITY;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;

import org.hibernate.envers.Audited;
import org.hibernate.validator.Length;
import org.hibernate.validator.NotNull;

import com.redhat.topicindex.utils.Constants;

/**
 * Filter generated by hbm2java
 */
@Entity
@Audited
@Table(name = "Filter", catalog = "Skynet", uniqueConstraints = @UniqueConstraint(columnNames = {"FilterName" })) 
public class Filter implements java.io.Serializable
{
	public static final String SELECT_ALL_QUERY = "select filter from Filter filter";
	/** Serializable version identifier */
	private static final long serialVersionUID = 1378015715100292871L;
	private Integer filterId;
	private String filterName;
	private String filterDescription;
	private Set<FilterTag> filterTags = new HashSet<FilterTag>(0);
	private Set<FilterCategory> filterCategories = new HashSet<FilterCategory>(0);
	private Set<FilterField> filterFields = new HashSet<FilterField>(0);

	public Filter()
	{
	}

	public Filter(final String filterName)
	{
		this.filterName = filterName;
	}

	public Filter(final String filterName, final String filterDescription, final Set<FilterTag> filterTags, final Set<FilterCategory> filterCategories)
	{
		this.filterName = filterName;
		this.filterDescription = filterDescription;
		this.filterTags = filterTags;
		this.filterCategories = filterCategories;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)
	@Column(name = "FilterID", unique = true, nullable = false)
	public Integer getFilterId()
	{
		return this.filterId;
	}

	public void setFilterId(Integer filterId)
	{
		this.filterId = filterId;
	}

	@Column(name = "FilterName", nullable = false, length = 512)
	@NotNull
	@Length(max = 512)
	public String getFilterName()
	{
		return this.filterName;
	}

	public void setFilterName(final String filterName)
	{
		this.filterName = filterName;
	}

	// @Column(name = "FilterDescription", length = 65535)
	@Column(name = "FilterDescription", columnDefinition = "TEXT")
	@Length(max = 65535)
	public String getFilterDescription()
	{
		return this.filterDescription;
	}

	public void setFilterDescription(final String filterDescription)
	{
		this.filterDescription = filterDescription;
	}

	@OneToMany(fetch = FetchType.EAGER, mappedBy = "filter", orphanRemoval = true, cascade = CascadeType.ALL)
	public Set<FilterTag> getFilterTags()
	{
		return this.filterTags;
	}

	public void setFilterTags(final Set<FilterTag> filterTags)
	{
		this.filterTags = filterTags;
	}

	@OneToMany(fetch = FetchType.EAGER, mappedBy = "filter", orphanRemoval = true, cascade = CascadeType.ALL)
	public Set<FilterCategory> getFilterCategories()
	{
		return this.filterCategories;
	}

	public void setFilterCategories(final Set<FilterCategory> filterCategories)
	{
		this.filterCategories = filterCategories;
	}

	@OneToMany(fetch = FetchType.EAGER, mappedBy = "filter", orphanRemoval = true, cascade = CascadeType.ALL)
	public Set<FilterField> getFilterFields()
	{
		return filterFields;
	}

	public void setFilterFields(final Set<FilterField> filterFields)
	{
		this.filterFields = filterFields;
	}

	/**
	 * Loops through the FilterTags held by this Filter, and returns the state
	 * of the tag if it exists, and -1 if it does not.
	 * 
	 * @param tagID The id of the tag to get the state of
	 * @return -1 if the tag was not found, otherwise the state of the tag
	 */
	public int hasTag(final Integer tagID)
	{
		for (final FilterTag tag : this.getFilterTags())
		{
			if (tag.getTag().getTagId().equals(tagID))
				return tag.getTagState();
		}

		return -1;
	}

	public ArrayList<Integer> hasCategory(final Integer categoryId)
	{
		ArrayList<Integer> states = new ArrayList<Integer>();

		for (final FilterCategory cat : this.getFilterCategories())
		{
			if (cat.getCategory().getCategoryId().equals(categoryId))
				states.add(cat.getCategoryState());
		}

		return states;
	}

	/**
	 * Not all FilterTags assigned to a filter have an associated
	 * FilterCategory. If a FilterTags belongs to a category that does not have
	 * an associated FilterCategory, the default boolean logic is used.
	 * 
	 * This function returns all the categories that the tags in this filter
	 * belong to. These are then matched to any associated FilterCategorys to
	 * find out how the tags are matched (i.e. are we matching all the tags
	 * ("And" logic), or one or more of the tags matches ("Or" logic)), using
	 * the default logic ("Or") if no associated FilterCategory exists.
	 * 
	 * @return An ArrayList containing the Category IDs that the tags in this
	 *         filter belong to
	 */
	@Transient
	public ArrayList<Category> getFilterTagCategories()
	{
		final ArrayList<Category> categories = new ArrayList<Category>();

		for (final FilterTag tag : this.filterTags)
		{
			for (final TagToCategory category : tag.getTag().getTagToCategories())
				if (!categories.contains(category.getCategory()))
					categories.add(category.getCategory());
		}

		return categories;
	}

	@Transient
	public ArrayList<Project> getFilterTagProjects()
	{
		final ArrayList<Project> projects = new ArrayList<Project>();

		for (final FilterTag filterTag : this.filterTags)
		{
			final Tag tag = filterTag.getTag();
			final Set<TagToProject> tagToProjects = tag.getTagToProjects();

			if (tagToProjects.size() != 0)
			{
				for (final TagToProject tagToProject : tagToProjects)
				{
					final Project project = tagToProject.getProject();

					if (!projects.contains(project))
						projects.add(project);
				}
			}
			else
			{
				if (!projects.contains(null))
					projects.add(null);
			}
		}

		return projects;
	}

	@Transient
	public String getFilterTitle()
	{
		String desc = "";
		
		/* Loop over all the categories that the filter tags belong to */
		for (final Category category : this.getFilterTagCategories())
		{
			String categoryDesc = category.getCategoryName() + ": ";
			String tagDesc = "";
			
			/* This will be shown in the topic list results title */
			String internalLogic = Constants.DEFAULT_INTERNAL_LOGIC;
			
			/* Find out if the category does not have the default internal logic */
			final Set<FilterCategory> filterCategories = this.getFilterCategories();
			for (final FilterCategory filterCategory : filterCategories)
			{
				/* if a filter category has been saved that matches the category we are looking at now.. */ 
				if (filterCategory.getCategory().equals(category))
				{
					/* ...and it defines an internal logic state, update the internalLogic variable */
					if (filterCategory.getCategoryState() == Constants.CATEGORY_INTERNAL_AND_STATE)
						internalLogic = Constants.AND_LOGIC;
					else if (filterCategory.getCategoryState() == Constants.CATEGORY_INTERNAL_OR_STATE)
						internalLogic = Constants.OR_LOGIC;
					break;
				}
			}

			for (final FilterTag tag : this.filterTags)
			{
				if (tag.getTag().isInCategory(category.getCategoryId()))
				{
					if (tagDesc.length() != 0)
						tagDesc += " " + internalLogic + " ";
					
					if (tag.getTagState() == Constants.NOT_MATCH_TAG_STATE)
						tagDesc += "Not ";

					tagDesc += tag.getTag().getTagName();
				}
			}

			if (desc.length() != 0)
				desc += " ";

			desc += categoryDesc + tagDesc;
		}

		if (this.getFilterFields().size() != 0)
		{
			String searchFilters = "";

			for (final FilterField filterField : this.getFilterFields())
			{
				if (searchFilters.length() != 0)
					searchFilters += ", ";
				searchFilters += " " + filterField.getDescription() + " = " + filterField.getValue();
			}

			if (desc.length() != 0)
				desc += " ";

			desc += "Search Filters:" + searchFilters;
		}

		return "[ " + desc + " ]";
	}

	/**
	 * Translate the contents of this filter, its tags and categories into
	 * variables that can be appended to a url
	 * 
	 * @return
	 */
	@Transient
	public HashMap<String, String> getUrlVariables()
	{
		final HashMap<String, String> vars = new HashMap<String, String>();

		for (final FilterTag filterTag : this.filterTags)
		{
			final Tag tag = filterTag.getTag();

			if (filterTag.getTagState() == Constants.MATCH_TAG_STATE)
			{
				vars.put(Constants.MATCH_TAG + tag.getTagId(), Constants.MATCH_TAG_STATE + "");
			}
			else if (filterTag.getTagState() == Constants.NOT_MATCH_TAG_STATE)
			{
				vars.put(Constants.MATCH_TAG + tag.getTagId(), Constants.NOT_MATCH_TAG_STATE + "");
			}
		}

		for (final FilterCategory filterCategory : this.filterCategories)
		{
			final Category category = filterCategory.getCategory();
			final Project project = filterCategory.getProject();

			if (filterCategory.getCategoryState() == Constants.CATEGORY_INTERNAL_AND_STATE)
			{
				vars.put(Constants.CATEORY_INTERNAL_LOGIC + category.getCategoryId() + (project == null ? "" : "-" + project.getProjectId()), Constants.AND_LOGIC);
			}

			// don't add a url var for the "or" internal logic, as this is the
			// default

			else if (filterCategory.getCategoryState() == Constants.CATEGORY_EXTERNAL_OR_STATE)
			{
				vars.put(Constants.CATEORY_EXTERNAL_LOGIC + category.getCategoryId() + (project == null ? "" : "-" + project.getProjectId()), Constants.OR_LOGIC);
			}

			// don't add a url var for the "and" external logic, as this is the
			// default
		}

		boolean foundFilterField = false;
		boolean foundFilterFieldLogic = false;
		for (final FilterField filterField : this.getFilterFields())
		{
			vars.put(filterField.getField(), filterField.getValue());
			if (!filterField.getField().equals(Constants.TOPIC_LOGIC_FILTER_VAR))
				foundFilterField = true;
			else
				foundFilterFieldLogic = true;
		}

		/*
		 * if we have found some filter fields, but did not find the filter
		 * logic, use the default value
		 */
		if (foundFilterField && !foundFilterFieldLogic)
			vars.put(Constants.TOPIC_LOGIC_FILTER_VAR, Constants.TOPIC_LOGIC_FILTER_VAR_DEFAULT_VALUE);

		return vars;
	}

	public String buildFilterUrlVars()
	{
		final HashMap<String, String> vars = this.getUrlVariables();
		String urlVars = "";

		for (final String urlVarKey : vars.keySet())
		{
			if (urlVars.length() != 0)
				urlVars += "&";
			urlVars += urlVarKey + "=" + vars.get(urlVarKey);
		}

		return urlVars;
	}

}
